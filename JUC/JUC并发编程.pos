{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","structure":"mind_right","leftChildren":[],"title":"JUC并发编程","watermark":"","root":true,"theme":"delicate_caihong","children":[{"id":"7091f6beaf3b","title":"synchronized锁","lineStyle":{"randomLineColor":"#0D7C82"},"children":[{"id":"2ea02849b9da","title":"问题：线程也可以唤醒，而不会被通知，中断或超时，即所谓的虚假唤醒 ","children":[{"id":"93bdd594cf75","title":"原因：就是用if判断的话，唤醒后线程会从wait之后的代码开始运行，但是不会重新判断if条件，直接继续运行if代码块之后的代码，而如果使用while的话，也会从wait之后的代码运行，但是唤醒后会重新判断循环条件，如果不成立再执行while代码块之后的代码块，成立的话继续wait。","parent":"2ea02849b9da","children":[]},{"id":"5c4d3fc55fe5","title":"解决：把if判断改成while判断等待，因为if判断进if之后不会停，用while判断的话，变量一旦被修改，另外一个线程拿到锁之后，就会等待，防止虚假唤醒","children":[],"parent":"2ea02849b9da"}],"parent":"7091f6beaf3b"}],"parent":"root"},{"id":"76bb38208968","title":"Lock锁","lineStyle":{"randomLineColor":"#DD489D"},"children":[{"id":"089be26b600a","title":"公平锁：十分公平，先来后到，排队.<br>非公平锁：不公平，可以插队<br>默认是非公平锁，是为了公平，比如一个线程要3s，另一个线程要3h,难道一定要让3h的锁先来就先执行吗","children":[],"parent":"76bb38208968"},{"id":"ddd50727555c","title":"ReentrantLock() 无参时默认是非公平锁","children":[],"parent":"76bb38208968"},{"id":"d585655bc81c","title":"实现类","children":[{"id":"78e0048535c6","title":"ReentrantLock（可重入锁）","children":[],"parent":"d585655bc81c"},{"id":"99c0057e5594","title":"ReentrantReadWriteLock.ReadLock （读锁）","parent":"d585655bc81c","children":[]},{"id":"f27e58562019","title":"ReentrantReadWriteLock.WriteLock （写锁）","children":[],"parent":"d585655bc81c"}],"parent":"76bb38208968"}],"parent":"root"},{"id":"3dadebac4ff6","title":"Synchronized和Lock锁的区别","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"id":"bd119691e3af","title":"Synchronized是内置的Java关键字，Lock是一个java类（还是接口呢？）","children":[],"parent":"3dadebac4ff6"},{"id":"eef75db3417d","title":"Synchronized无法判断获取锁的状态，Lock可以判断是否获取了锁","children":[],"parent":"3dadebac4ff6"},{"id":"2391d0d71fbc","title":"Synchronized会自动释放锁，Lock锁必须要手动释放锁，如果不释放锁，会死锁","children":[],"parent":"3dadebac4ff6"},{"id":"6d24a6cd3018","title":"如果有两个线程，使用Synchronized时，如果线程1获得了锁，那么线程2会等待，线程1阻塞了，线程2也会死等。使用Lock锁时，Lock锁不一定会等待，Lock有一个方法，Lock.tryLock();会去尝试获取锁","children":[],"parent":"3dadebac4ff6"},{"id":"50794addba3e","title":"Synchronized 可重入锁，不看可以在中断，非公平。 Lock：可重入，可以判断锁，可以设置公平或者非公平","children":[],"parent":"3dadebac4ff6"},{"id":"0ab3775d34eb","title":"Synchronized适合锁少量的代码同步问题。Lock锁适合锁大量的同步代码","children":[],"parent":"3dadebac4ff6"},{"id":"de97eca0b8b6","title":"使用lock方法代替synchronized方法，并使用await和signal方法替代wait和notifyall方法。","children":[],"parent":"3dadebac4ff6"}],"parent":"root"},{"id":"45b4bb8043db","title":"锁的8大问题","lineStyle":{"randomLineColor":"#FA5465"},"parent":"root","children":[]},{"id":"a1571acc35f3","title":"不安全的集合","lineStyle":{"randomLineColor":"#02ACF4"},"parent":"root","children":[{"id":"5502b5f564cc","title":"List","children":[{"id":"2596d8c52079","title":"解决方法：1.使用Vector2.Collections.synchronizedList(new ArrayList&lt;&gt;())3.new CopyOnWriteArrayList&lt;&gt;()","children":[],"parent":"5502b5f564cc"}],"parent":"a1571acc35f3"},{"id":"23e1b40a4259","title":"Set","children":[{"id":"bd02ce30dc8a","title":"解决方法： 1、Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());2、Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();","children":[],"parent":"23e1b40a4259"}],"parent":"a1571acc35f3"},{"id":"d5d7f14b7361","title":"map","parent":"a1571acc35f3","children":[{"id":"8b1e8fe97e76","title":"使用ConcurrentHashMap","parent":"d5d7f14b7361","children":[]}]}]}],"note":""}},"meta":{"id":"604b0d9f63768958e9962bad","member":"6009505ef346fb77714aee48","exportTime":"2021-03-15 17:21:59","diagramInfo":{"category":"mind_free","title":"JUC并发编程","created":"2021-03-12 14:43:43","creator":"6009505ef346fb77714aee48","modified":"2021-03-15 13:07:03"},"type":"ProcessOn Schema File","version":"1.0"}}