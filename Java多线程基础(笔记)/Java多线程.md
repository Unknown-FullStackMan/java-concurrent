## Java多线程

https://blog.csdn.net/Ares___/article/details/120636631

### 线程创建



#### 实现Thread类

Thread类实现了Runnable接口，它们之间具有多态关系



线程实现Thread类执行到start()方法时，程序运行过程

1）通过JVM告诉操作系统创建Thread。
2）操作系统开辟内存并使用Windows SDK中的createThread()函数创建Thread线程对象。
3）操作系统对Thread对象进行调度，以确定执行时机。
4）Thread在操作系统中被成功执行。





#### 实现Runnable接口



**实现Runnable接口方法启动一个线程的执行过程和使用继承Thread类启动一个线程时的执行过程是不一样的：**

JVM直接调用的是Thread.java类的run()方法，该方法源代码如下：

```java
@Override
public  void  run()  {
    if  (target  !=  null)  {
        target.run();
    }
}
```



在方法中判断target变量是否为null，不为null则执行target对象的run()方法，target存储的对象就是前面声明的MyRunnable run对象，对Thread构造方法传入Runnable对象，再结合if判断就可以执行Runnable对象的run()方法了。变量target是在init()方法中进行赋值初始化的，核心源代码如下：

```java
private  void  init(ThreadGroup  g,  Runnable  target,  String  name,long  stackSize,  AccessControlContext  acc,boolean  inheritThreadLocals)  {
    ……
   this.target  =  target;
    ……
}
```

而方法init()是在Thread.java构造方法中被调用的，源代码如下：

```java
public  Thread(Runnable  target)  {
    init(null,  target,  "Thread-"  +  nextThreadNum(),  0);
}
```





MyThread.java类的构造函数是被main线程调用的,MyThread.java类的构造函数是被main线程调用的，而run()方法是被名称为Thread-0的线程调用的，run()方法是自动调用的方法。



执行方法run()和start()还是有一些区别的。
1）my.run()；：立即执行run()方法，不启动新的线程。
2）my.start()；：执行run()方法时机不确定，启动新的线程





### 线程状态

```
/**
 * 线程的生命周期时线程对象的生老病死，即线程的状态
 * 线程的生命周期可以通过getState()方法获得,线程状态是Thread.State枚举定义的，有以下几种：
 * NEW 新建状态。创建线程对象，在调用start（）启动之间的状态
 *
 * RUNNABLE 可运行状态。是个复合状态，包含：READY和RUNNING两个状态。
 *              READY是start（）方法执行后。
 *              READY是该线程可以被调度器进行调度使他处于RUNNING状态
 *              Thread.yield()方法可以把线程从RUNNING转到READY状态
 *
 * BLOCKED 阻塞状态。线程发起阻塞的I/O操作，或者申请由其他线程独占的资源，线程会转换为BLOCKED 阻塞状态，不会占用cpu资源。当阻塞I/O操作执行完
 * 或者线程获得了其申请的资源，线程可以转换为RUNNABLE。
 *
 * WAITING 等待状态。线程执行了Object.wait()，Thread.join()方法会把线程转换为WAITING状态，执行Object.notify()方法，或者加入的线程执行完毕，当前线程会转换为RUNNABLE
 *
 * TIMED_WAITING 与WAITING类型，等待状态。不会无限等待，如果线程没有在指定的时间范围内完成期望的操作，该线程会转换为RUNNABLE
 *
 * TERMINATED 终止状态，线程结束
 *
 */
```



![image-20210826112332013](C:\Users\A\Desktop\Java多线程基础\Java多线程.assets\image-20210826112332013.png)



https://blog.csdn.net/pange1991/article/details/53860651





### 多线程编程的问题

+ 线程安全问题。多线程共享数据时，如果没有采取正确的并发访问控制措施，就可能会产生数据一致性问题。如脏读，丢失数据更新。
+ 线程活性问题。由于程序自身的缺陷或者由资源稀缺性导致线程一直处于非RUNNABLE状态，这就是线程活性问题，常见的活性故障有：
  + 死锁（Deadlock）
  + 锁死（Lockout）
  + 活锁（Livelock）
  + 饥饿（Starvation)
+ 上下文切换。处理器从执行一个线程切换到执行另外一个线程
+ 可靠性。可能会由一个线程导致JVM意外终止，其他线程也无法执行

#### 线程安全问题

非线程安全主要是值多个线程对同一个对象的实例变量进行操作时会出现值被更改，值不同步的情况

线程安全问题表现为三个方面：原子性，可见性，有序性



##### 原子性

原子（Atomic），不可分割。原子操作的不可分割由两层含义：

+ 访问（读，写）某个共享变量的操作从其他线程来看，操作要么执行完毕，要么尚未发生。没有中间态
+ 访问同一组共享变量的原子操作是不能够交错的



Java两种方式实现原子性：

+ 使用锁。锁具有排他性，保证共享变量在某一时刻只能被一个线程访问。

+ 利用处理器的CAS（Compare and Swap）指令。CAS指令直接在硬件（处理器和内存）层次上实现，看作是硬件锁。

  

##### 可见性

 	在多线程环境中，一个线程对某个共享变量进行更新之后，后续其他线程可能无法立刻读到这个更新的结果。这就是线程安全问题的另外一种形式：可见性（visiblity）

​	如果一个线程对共享变量更新后，后续访问该变量的其他线程可以读到更新的结果，称这个线程对共享变量的更新对其他线程可见

否则不可见。

​	对线程程序因为可见性问题会造成很多例如数据脏读等问题。

**在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。**



http://ifeve.com/easy-happens-before/



##### 有序性

​	有序性（Ordering）是指在什么情况下一个处理器上运行的一个线程所执行的 内存访问操作在另外一个处理器运行的其他线程看来是乱序的（Out  of  Order）

​	乱序是指内存访问操作的顺序看起来发生了变化。



在多核处理器的环境下，编写的代码顺序结构，这种操作执行的顺序可能是没有保障的：

   编译器可能会改变两个操作的先后顺序；

   处理器也可能不会按照目标代码的顺序执行；

​	这种一个处理器上执行的对个操作，在其他处理器来看他的顺序与目标代码指定的顺序可能不一样，这种现象叫重排序。

​	重排序是对内存访问有序操作的一种优化，可以在不影响单线程程序正确的情况下提升程序的性能，但是可能对多线程程序的正确性产生影响，即可能导致线程安全问题。

**重排序**：执行任务的时候，为了提高编译器和处理器的执行性能，**编译器和处理器(包括内存系统，内存在行为没有重排但是存储的时候是有变化的)会对指令重排序**。编译器优化的重排序是在编译时期完成的，指令重排序和内存重排序是处理器重排序。

   重排序与可见性问题类似，不是必然出现。

https://blog.csdn.net/qq_41174684/article/details/90631746



##### 指令重排序

​	在源码顺序与程序顺序不一致或者程序顺序与执行顺序不一致的情况下，就是指令重排序。

​	指令重排序是一种动作，确实对指令的顺序做了调整，javac编译器一般不会执行指令重排序，而JIT编译器可能执行指令重排序；处理器也可能执行指令重排序。

##### 存储子系统重排



##### 貌似串行语义

JIT编译器、处理器、存储子系统是按照一定的规则对指令，内存操作的结果进行重排序，给单线程程序超成一种假象——指令是按照源码的顺序执行的，这种假象称为貌似串行语义。并不能保证多线程环境程序的正确性。

为了保证貌似串行语义有数据依赖关系的语句不会被重排序，只有不存在数据依赖关系的语句才会被重排序。如果两个操作访问同一个变量，且其中一个操作为写操作，那么这两个操作之间就存在**数据依赖关系。**

​	x = 1； y = x + 1;

如果不存在数据依赖关系则可能重排序，如

double price = 45.8

int quantity = 10



存在控制依赖关系的语句允许重排。一条语句的执行结果会决定另一个语句能否被执行，这两条语句存在控制依赖关系。如在if语句中允许重排，可能存在处理器先执行if代码块，再判断if条件是否成立。



![image-20210827094204509](C:\Users\A\Desktop\Java多线程基础\Java多线程.assets\image-20210827094204509.png)

![image-20210827094447667](C:\Users\A\Desktop\Java多线程基础\Java多线程.assets\image-20210827094447667.png)



### 锁

线程安全问题的产生前提是多个线程并发访问共享数据。

将多个线程对共享数据的并发访问转换为串行访问，即一个共享数据一次只能被一个线程访问。锁就是复用这种思路来保障线程安全的。

锁（Lock）可以理解为对共享数据进行保护的一个许可证。对于同一个许可证保护的共享数据来说，任何线程想要访问这些共享数据必须先持有许可证。一个线程只有在持有许可证的情况下才能对这些共享数据进行访问；并且一个许可证一次只能被一个线程持有。许可证线程在结束对共享数据的访问后必须释放其持有的许可证。

一个线程在访问共享数据前必须先获得锁；获取锁的线程称为锁的持有线程；一个锁一次只能被一个线程持有。锁的持有线程在获得锁之后和释放锁之前这段时间里所执行的代码称为临界区（Critical Section）

锁具有排他性（Exclusive），即一个锁一次只能被一个线程持有。这种锁称为排它锁或互斥锁（Mutex）

![image-20210830185743629](C:\Users\A\Desktop\Java多线程基础\Java多线程.assets\image-20210830185743629.png)



#### JVM把锁分为内部锁和显示锁两种。

**内部锁通过synchronized关键字实现；显示锁通过java.concurrent.locks.Lock接口的实现类实现的。**



#### 锁的作用

锁可以实现对共享数据的安全访问，保障线程的原子性，可见性与有序性

锁是通过互斥保障原子性。一个锁只能被一个线程持有，这就保障临界区的代码一次只能被一个线程执行。具有不可分割性的特性。

可见性的保障是通过写线程冲刷处理器的缓存和读线程刷新处理器缓存这两个动作实现的，在java平台中锁的获得隐含着刷新处理器缓存的动作，锁的释放隐含着冲刷处理器缓存的动作。

锁保障有序性，写线程在临界区所执行的在读线程所执行的临界区看来像是完全按照源码顺序执行的。

注意：

使用锁保障线程的安全性，必须满足以下条件：

​	这些线程在访问共享数据的时候必须使用同一个锁

​	即使是读取共享数据的线程也需要使用同步锁

#### 可重入性（Reentrancy）

​	一个线程持有该锁的时候能再次（多次）申请该（同一）锁

```java
void methodA(){
    申请a锁
    methodB(){};
    释放a锁
}

void methodB(){
    申请a锁
       .....
    释放a锁
}
```



如果一个线程持有锁的时候还能够继续成功申请到该锁。称为该锁是可重入的，否则是不可重入。

#### 锁的争用与调度

Java平台中内部锁属于非公平锁，显示Lock锁既支持公平锁又支持非股公平锁



#### 锁的粒度

一个锁可以保护的共享数据的数量大小称为锁的粒度。

锁保护共享数据量大，称该锁的粒度粗，反之叫锁的粒度细。

锁的粒度过粗会导致线程在申请锁时会进行不必要的等待，锁的粒度过细会增加锁的调度的开销。



#### 内部锁

**synchronized关键字**

Java中的每个对象都有一个与之关联的内部锁（Intrinsic lock）。这种锁也称为监视器（Monitor），这种内部锁是一个排它锁，可以保障原子性可见性与有序性。

内部锁通过synchronized关键字实现，synchronized关键字修饰代码块，修饰该方法。

修饰代码块的语法：

​		synchronized（对象锁）{

​				同步代码块，可以在同步代码快中访问共享数据

}

修饰实例方法就称为同步实例方法

修饰静态方法就称为同步静态方法



### 轻量级同步机制：volatile关键字

#### 线程间可见	

volatile关键字的作用使变量在多个线程间可见。



#### volatile与synchronized比较

+ volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好； volatile只能修饰变量，而synchronized修饰方法，代码块。随着JDK新版本的发布，synchronized的执行效率也有很大的提升。在开发中使用synchronized的比率还是很大的。
+ 多线程访问volatile变量不会发生阻塞，而synchronized可能会阻塞
+ volatile能保证数据的可见性，但是不能保证原子性；synchronized都可以保证。
+ volatile解决的是变量在多个线程之间的可见性；synchronized解决多个线程之间的访问公共资源的同步性。

#### volatile不保证原子性



### CAS

CAS(Compare And Swap)是由硬件实现的

cas可以将read-modify -write这类的操作转换为原子操作

i++自增操作包括三个子操作

​	从主内存读取i变量值

​	对i的值加1

​	再把加1之后的值保存到主内存



#### 原理

CAS原理：在把数据更新到主内存时，再次读取主内存变量的值，如果现在变的值与期望的值一样就更新。否则不更新。



![image-20210902143507825](C:\Users\A\Desktop\Java多线程基础\Java多线程.assets\image-20210902143507825.png)



#### ABA问题

A->B->A，在这个过程中其他线程不知道A的值被修改过

加入修订号（同乐观锁原理-version），每次修改修订号+1；

AtomicStampedReference类就是基于这种思想。



### 原子操作类

原子数组：AtomicIntegerArray

原子更新器：AtomicIntegerFieldUpdater，更新的字段必须是volatile修饰和不能为final

原子类：AtomicLong、AtomicInteger

原子操作对象：AtomicReference、AtomicStampedReference（可解决ABA问题）





### 线程间通信



#### 等待/通知

Object类的wait（）方法可以使执行当前代码的线程等待，暂停执行，直到接到通知或被中断为止。

注意

+ wait()方法只能在同步代码块中由锁对象调用
+ 调用wait()方法，当前线程会释放锁

Object类的notify（）可以唤醒线程，该方法也必须在同步代码块中由锁对象调用。没有使用锁对象调用 wait()/notify()会抛出illegalMonitorStateException异常。如果由多个线程，notify()只能随机唤醒一个线程。调用notify()方法后不会立即释放锁对象，要等到当前同步代码块执行完后才会释放锁对象，所以一般将notify()方法放在同步代码块的最后。

notifyAll()唤醒所有等待线程

wait(long)带有long类型的wait（）等待，如果在参数指定的时间内没有被唤醒，超时后会被自动唤醒。



通知过早

​	线程wait()等待后，可以调用notify()唤醒线程，如果notify()唤醒的过早，在等待之前就调用notify()可能会打乱程序正常的运行逻辑。



#### 生产者消费者



**操作值**

**操作栈**



#### 管道

通过管道实现线程间通信

在java.io包中的PipeStream管道流用于线程之间传输数据，一个线程发送数据到输出管道，另外一个线程从输入管道中读取数据。

类：

PipedInputStream、PipedOutputStream、PipedReader和PipedWriter。



### ThreadLocal

除了控制资源的访问外，还可以通过增加资源来保证线程安全

ThreadLocal主要解决每个线程绑定自己的值



### Lock显示锁

在JDK5中新增了`java.util.concurrent.locks包`下的Lock接口。有ReentrantLock实现类,ReentrantLock锁称为可重入锁, 它功能比synchronized多。

#### 锁的可重入性

是指,当一个线程获得一个对象锁后,再次请求该对象锁时是可以获得该对象的锁的。synchronized关键字就是使用的重入锁。



我们先来看看synchronized有什么不足之处。

如果临界区是只读操作，其实可以多线程一起执行，但使用synchronized的话，同一时间只能有一个线程执行。
synchronized无法知道线程有没有成功获取到锁
使用synchronized，如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程又没有释放锁，就会导致所有线程等待。

而这些都是locks包下的锁可以解决的。



Lock的基本使用：

1.lock获得锁，unlock释放锁(lock锁必须主动释放)

2.lockInterruptibly()  ：如果当前线程未被中断，则获取锁，可以响应中断   

3.tryLock（）  通过该方法实现锁对象的限时等待

对于synchronized內部锁来说，如果一个线程在等待锁，只有两个结果：要么获得锁，要么保持等待

对于ReentrantLock可重入锁来说，提供另外一种可能，在等待锁的过程中，程序可以根据取消对锁的请求。 



#### 避免死锁：

lockInterruptibly（） 可以解决死锁。

tryLock（）也可以不避免死锁



